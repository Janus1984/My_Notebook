### 选择排序

----

1. 每一次从待排序的数据元素中选出最小（最大）的一个元素，存放在序列的起始位置。

2. 然后再从剩余未排序元素中继续寻找最小（最大）元素，然后放到已排序序列的末尾。

3. 直到全部排完。

时间复杂度$O(n^2)$



### 快速排序

----

**快速排序就是个二叉树的前序遍历**

快排的逻辑：对于需要排序的`nums[a1...an]`,我们先找一个分界点p，通过交换元素使得`nums[a1...p-1]`都小于等于`nums[p]，nums[p+1,...,an]`都大于`nums[an]`，然后递归地对两个子数组重复上述行为，直到整个数组被排序。

这里分界点对应于二叉树的根节点，两个子数组对应根节点的左右子树。

----

本质是二分法

先选取array[0]作为基准值，遍历数组，比基准值小的元素放到基准值左边，比基准值大的元素放到基准值右边，然后对两个子数组重复上述操作。

时间复杂度$O(nlogn)$，最糟情况下为$O(n^2)$，速度取决于选择的基准值。

```python
def quicksort(array):  
    if len(array) < 2:     
        return array  
    else:     
        pivot = array[0]     
        less = [i for i in array[1:] if i <= pivot]     
        greater = [i for i in array[1:] if i > pivot]   
        return quicksort(less) + [pivot] + quicksort(greater)
```



### 归并排序

----

**归并排序就是个二叉树的后序遍历**

先对左右子数组排序，然后合并。

