### C++编译模式

C++语言支持分离式编译（separate compilation），把程序的各个部分分别存储在不同文件下，每个文件独立编译。

> 比如在a.cpp中定义了一个全局函数，在文件b.cpp中要调用这个函数时，只需要声明一下这个函数就行，a和b并不需要互相知道对方的存在，可以分别编译，在编译成目标文件后再链接，整个程序就可以运行了。
>
> 怎么实现的？编译器在编译b.cpp时会生成一个符号表（symbol table），看不到的定义的符号就会存放到这个符号表中，在链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义，一旦找到了，程序就顺利地生成了。



### 头文件

所谓头文件，内容和.cpp文件一样，都是C++源代码，但头文件不用被编译。当某个。cpp源文件需要头文件内容时，用宏命令#include将头文件包含进源文件中即可。

``` C++
/* math.h */
double f1();
double f2(double);
/* end of math.h */
```

``` C++
/* math.cpp */
#include"math.h"
double f1()
{
    //do something here...
}

double f2(double a)
{
    //do something here...
}
/* end of math.cpp */
```

> #include 作用其实就是在预编译阶段，将它后面所写的那个文件的内容，完完整整的包含到当前的文件中来。简单的文本替换。



### 头文件中应该写什么

头文件中只能存在变量或者函数的声明，而不要放定义。

除此之外，有三个例外：

- 头文件中可以写const对象的定义。
- 头文件中可以写内联函数的定义。
- 头文件中可以写类的定义。

> 通常的做法是，把类的定义放在头文件中，而把函数成员的实现代码放在一个.cpp文件中。



### 头文件保护符

如果头文件中只有声明，那它被同一个.cpp文件包含多少次都没问题，但是头文件中可能存在定义，当头文件之间存在依赖关系时可能出现重复定义，而一个源文件中只能出现一次定义，所以头文件需要头文件保护符（`#ifndef...#endef`）来防止错误发生。

> 例子：比如a.h中含有类A的定义，b.h中含有类B的定义，类B的定义依赖类A。c.cpp需要同时用到类A和类B，所以同时include了a.h和b.h，此时就出现了重复定义类A。

``` C++
#ifndef A_H
#define A_H
struct A
{
    int a = 0;
};
#endif
```

> `A_H`称为预处理变量，用来指代头文件保护符内定义的内容，通常用头文件中类的名字的大写来命名。

> 预处理变量无视C++语言中关于作用域的规则。[^1]
>

----

##### 源文件如何根据#include来关联头文件

#include

系统自带的头文件用尖括号，用户自定义的用双引号。

##### 头文件如何来关联源文件

`#include “a.h”`编译的时候并不会去找函数的实现，只是为了引入声明，使得编译可以通过。而在链接阶段，需要在makefile里说明需要链接哪个目标文件。

----

### Google 风格

1. 每个.cpp文件都对应一个.h文件。除了单元测试代码和只包含`main()`函数的.cpp文件。
2. 头文件应该自给自足（self-contained）。[^2]
3. 所有头文件都应该使用`#ifndef...#endif`来防止头文件被多重包含，命名格式为：`<progerct>_<path>_<file>_H`.

4. 尽量避免前置声明那些定义在其他项目中的实体。



###　参考

[理解 C++ 中的头文件和源文件的作用 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/cpp-header.html)

[^1]: C++ Primer page.68 ↩
[^2]:即一个头文件要有`#difine`保护，完备的。用户和重构工具不需要为特别场合而包含额外的头文件。如果只是作为插入文本，则应该以`.inc`作为扩展名。

